#!/usr/bin/env python
# Version: v.23.08.03
# -*- coding: utf-8 -*-

import argparse
from string import Template
try:
    from venvwaftlib import *
except IOError:
    print("( ERROR ) : Run 'waft-addons-link' python script in '.venv-waft' virtual environment.")
    exit(1)

def split_line(line):
    splitted_lines = line.split(" ")
    for sl in splitted_lines:
        if sl == "":
            splitted_lines.pop(splitted_lines.index(sl))
    return splitted_lines


def is_in_history(value, history):
    for commit in history:
        if commit[:8] == value[:8]:
            return True
    return False


def decode_variables(string):
    """
    pass a string and return variables replaced in it.
    @returns string
    """
    # may be int, str
    string = str(string)
    yaml_substituted = Template(string)
    return yaml_substituted.substitute(os.environ)


def preprocess_merge(doc, repo, merge):
    remotes = doc[repo]["remotes"].keys()
    splitted_merge = [x for x in merge.split(" ") if x != ""]
    if splitted_merge[0] not in remotes:
        logger.debug("Invalid Remote on line: %s" % merge)
        raise ValueError
    repo_path = os.path.abspath(os.path.join(SRC_DIR, repo))
    return repo_path, splitted_merge


def get_branchname(splitted_merge, merge_type):
    if merge_type in (1, 3):
        return decode_variables(splitted_merge[1])
    return False

def get_merge_type(splitted_merge, repo):
    """
    Possible syntaxes for merges:

    <remote> <branch>     merge_type=1
    <remote> <PIN>        merge_type=2
    <remote> <branch> <PIN>     merge_type=3
    merge_type=0  "invalid"
    """
    all_commits = {}
    if len(splitted_merge) == 3:
        return 3
    else:
        if is_in_history(splitted_merge[1], all_commits.get(repo, [])):
            return 2
        else:
            return 1
    return 0  # unreachable.


def process_depth(splitted_merge, branchname, main_branch, main_branch_name, repo_path):
    os.chdir(repo_path)
    # make sure we have the latest branch available.
    run(
        [
            "git",
            "fetch",
            splitted_merge[0],
            branchname,
        ],
        stdout=PIPE,
        stderr=PIPE,
    )
    # look at most recent common commit.
    lastrev = (
        run(
            [
                "git",
                "merge-base",
                "".join([main_branch[0], "/", main_branch_name]),
                "".join([splitted_merge[0], "/", branchname]),
            ],
            stdout=PIPE,
            stderr=PIPE,
        )
        .stdout.decode("utf-8")
        .replace("\n", "")
    )
    if not lastrev:
        return 1024  # Can happen when remote not yet added.
    # we now calculate the needed depth of this branch
    mindepth = (
        run(
            [
                "git",
                "rev-list",
                "".join([main_branch[0], "/", main_branch_name]),
                "^" + lastrev,
                "--count",
            ],
            stdout=PIPE,
            stderr=PIPE,
        )
        .stdout.decode("utf-8")
        .replace("\n", "")
    )
    try:
        return int(mindepth)
    except Exception:
        # Should log/print some error here.
        return 1024


def main():
    """
    parsing directly repos.yaml, if something is not in addons.yaml, branch will still
    be in folder, but may not be included in addons. Nothing changes.
    """
    repo_min_depth = {}
    changes = ''
    with open(REPOS_YAML) as yaml_file:
        for doc in yaml.safe_load_all(yaml_file):
            for repo in doc:
                print("===>processing repo %s" % repo)
                repo_min_depth[repo] = 0
                if repo in {PRIVATE, "ONLY", "ENV"}:
                    continue
                target = doc[repo].get("target") or False
                # main branch is defined as target or in absence of target, merge[0]
                main_branch = split_line(target or doc[repo]["merges"][0])
                merge_type = get_merge_type(main_branch, repo)
                main_branch_name = get_branchname(main_branch, merge_type)
                for merge in doc[repo]["merges"]:
                    repo_path, splitted_merge = preprocess_merge(doc, repo, merge)
                    # this script cannot work on new ./builds it is written to keep
                    # depths of instances that have been built at least once with
                    # if one source folder is missing we skip it.
                    if not os.path.exists(repo_path):
                        continue
                    merge_type = get_merge_type(splitted_merge, repo)
                    branchname = get_branchname(splitted_merge, merge_type)
                    if branchname:
                        # compute depth only for merges with branchname
                        min_depth = process_depth(
                            splitted_merge,
                            branchname,
                            main_branch,
                            main_branch_name,
                            repo_path,
                        )
                        repo_min_depth[repo] = (
                            min_depth > repo_min_depth[repo]
                            and min_depth
                            or repo_min_depth[repo]
                        )
                        if repo_min_depth[repo] > 0:
                            waft_depth = decode_variables(
                                doc[repo]["defaults"].get("depth")
                            )
                            # just in case the substitution didn't happen because variables
                            # are not explicitly loaded in env...
                            if waft_depth == "${WAFT_DEPTH_MERGE}":
                                # waft_depth_merge, if not specified in env defaults to 100
                                waft_depth = os.environ.get("WAFT_DEPTH_MERGE") or 100
                            if waft_depth == "${WAFT_DEPTH_DEFAULT}":
                                waft_depth = os.environ.get("WAFT_DEPTH_DEFAULT") or 1
                            waft_depth = int(waft_depth)
                            if repo_min_depth[repo] > waft_depth:
                                changes += ("\n\t Increasing depth of %s from %s to %s"
                                    % (
                                        repo,
                                        doc[repo]["defaults"]["depth"],
                                        str(repo_min_depth[repo]),
                                    )
                                )
                                doc[repo]["defaults"]["depth"] = repo_min_depth[repo]

    if changes:
        print("========Applying Depth changes to repos.yaml:")
        print(changes)
        print("=======================================")
        yaml_file = open(REPOS_YAML, "w")
        yaml_file.write(yaml.dump(doc, default_flow_style=True, default_style='|', sort_keys=False))
        yaml_file.close()

if os.path.isfile(REPOS_YAML) and __name__ == "__main__":
    main()
else:
    logger.debug("no %s  repository file found" % REPOS_YAML)
    raise ValueError
